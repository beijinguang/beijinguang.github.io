<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码客Mark</title>
  <subtitle>预测未来最好的方法是在现在创造未来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://code.idea4j.com/"/>
  <updated>2020-09-11T05:38:21.345Z</updated>
  <id>http://code.idea4j.com/</id>
  
  <author>
    <name>markee</name>
    <email>wangjinguang66@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2%20JDK%20%E7%9A%84%E7%B1%BB/"/>
    <id>http://code.idea4j.com/2020/09/11/如何替换 JDK 的类/</id>
    <published>2020-09-11T10:46:51.726Z</published>
    <updated>2020-09-11T05:38:21.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何替换-JDK-的类"><a href="#如何替换-JDK-的类" class="headerlink" title="如何替换 JDK 的类"></a>如何替换 JDK 的类</h2><h3 id="如何替换jdk中的类呢？Java提供了endorsed技术。"><a href="#如何替换jdk中的类呢？Java提供了endorsed技术。" class="headerlink" title="如何替换jdk中的类呢？Java提供了endorsed技术。"></a>如何替换jdk中的类呢？Java提供了endorsed技术。</h3><p>关于 endorsed ：可以的简单理解为 -Djava.endorsed.dirs 指定的目录面放置的jar文件，将有覆盖系统API的功能。但是能够覆盖的类是有限制的，其中不包括java.lang包中的类(出于安全的考虑)。</p>
<h3 id="为什么必须使用-endorsed-进行替换-jdk-中的类呢？"><a href="#为什么必须使用-endorsed-进行替换-jdk-中的类呢？" class="headerlink" title="为什么必须使用 endorsed 进行替换 jdk 中的类呢？"></a>为什么必须使用 endorsed 进行替换 jdk 中的类呢？</h3><p>因为java是采用双亲委派机制进行加载class类的。而jdk提供的类只能由类加载器Bootstrap进行加载。如果你想要在应用程序中替换掉jdk中的某个类是无法做到的，所以java提供了endorsed来达到你想要替换到系统中的类。</p>
<h3 id="使用endorsed的两种方式："><a href="#使用endorsed的两种方式：" class="headerlink" title="使用endorsed的两种方式："></a>使用endorsed的两种方式：</h3><ul>
<li>运行的时候加上 -Djava.endorsed.dirs=D:\endorsed（jar包存放目录） 参数</li>
<li>将修改后的jar包放在：$JAVA_HOME/jre/lib/endorsed 、$JAVA_HOME/lib/endorsed 下面</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>本实例通过修改ArrayList来试验:</p>
<ol>
<li><p>新建maven工程，在工程中新建java.util.ArrayList</p>
</li>
<li><p>复制jdk中ArrayList源码到自己创建的ArrayList，并修改构造方法如下：</p>
</li>
</ol>
<p><img src="/2020/09/11/如何替换 JDK 的类/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200911114253815.png" alt="image-20200911114253815"></p>
<ol>
<li>将工程打包成jar，复制到endorsed文件夹中</li>
<li>新建测试类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.idea4j.endorsed.test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * -Djava.endorsed.dirs=D:\idea4j-endorsed\endorsed</div><div class="line"> * -XX:+TraceClassLoading</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List list = <span class="keyword">new</span> ArrayList();</div><div class="line">        System.out.println(<span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>修改运行参数，如图</li>
</ol>
<p><img src="https://gitee.com/idea4j/imagerep/raw/master/images/image-20200911114058420.png" alt="image-20200911114058420"></p>
<ol>
<li>运行Test，结果如下：</li>
</ol>
<p><img src="https://gitee.com/idea4j/imagerep/raw/master/images/image-20200911114454953.png" alt="image-20200911114454953"></p>
<p>看到Test类调用了我们修改的ArrayList，说明我们成功覆盖了jdk的类</p>
<p>但我们只调用一次new ArrayList(),为什么日志输出了这么多次呢？</p>
<p>我们在运行参数中在加入-XX:+TraceClassLoading看类加载过程可知，虚拟机启动时，有一些类调用了ArrayList默认构造器</p>
<p><img src="https://gitee.com/idea4j/imagerep/raw/master/images/image-20200911123505455.png" alt="image-20200911123505455"></p>
<p>上面我们使用了修改运行参数的方法，下面我们再试验第二种方法，把jar包copy到$JAVA_HOME/jre/lib/endorsed下，结果和上面一样。</p>
<p>但是copy到$JAVA_HOME/lib/endorsed下，结果是没有覆盖成功。这是为什么呢？如图，java-home应该为实际运行环境的目录。</p>
<p><img src="https://gitee.com/idea4j/imagerep/raw/master/images/image-20200911130242199.png" alt="image-20200911130242199"></p>
<p>经查看项目jdk配置</p>
<p><img src="https://gitee.com/idea4j/imagerep/raw/master/images/image-20200911125011220.png" alt="image-20200911125011220"></p>
<p>classpath指定的是jre，所以，把jar包copy到$JAVA_HOME/jre/lib/endorsed下才能成功也就说的通了。</p>
<p>#### </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何替换-JDK-的类&quot;&gt;&lt;a href=&quot;#如何替换-JDK-的类&quot; class=&quot;headerlink&quot; title=&quot;如何替换 JDK 的类&quot;&gt;&lt;/a&gt;如何替换 JDK 的类&lt;/h2&gt;&lt;h3 id=&quot;如何替换jdk中的类呢？Java提供了endorsed技术
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/%E7%B1%BB%E8%A3%85%E8%BD%BD/"/>
    <id>http://code.idea4j.com/2020/09/11/类装载/</id>
    <published>2020-09-11T10:46:51.719Z</published>
    <updated>2020-09-09T07:22:50.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类装载"><a href="#类装载" class="headerlink" title="类装载"></a>类装载</h2><pre class="mermaid">
graph LR

A(loading)-->B(verifying)-->C(preparing)-->D(resolving)-->E(initializing)-->F(using)-->G(unload)</pre>



<ul>
<li>在任何时刻，第一次<strong>访问</strong>某类，都会执行类装载</li>
<li>访问包括三种情况：<ul>
<li>使用某类的static方法</li>
<li>访问某类的static属性</li>
<li>构造某类的对象</li>
</ul>
</li>
<li>声明没有初始化的引用<code>Administrator admin;</code>,并不会导致类装载(This is lazy load)</li>
<li>一个类的装载只会执行一次</li>
</ul>
<p>类装载的工作清单：</p>
<ol>
<li>加载.class字节码文件：根据包语法决定的路径找到.class文件并加载</li>
<li>为static属性分配存储空间并全部置为默认值(Q:默认值是多少)</li>
<li>装载父类：如果这个类有父类，且父类还没有被装载过，则先装载它的父类；否则继续</li>
<li>进行类初始化：按照类定义中的顺序，从上到下初始化static属性和执行static块中的语句</li>
</ol>
<ul>
<li><p>如果使用赋值运算符显示赋值，就执行赋值操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static int count=0;</div></pre></td></tr></table></figure>
<ul>
<li>如果等号右边的值所述的类尚未被装载，那么先装载等号右边的类再赋值</li>
</ul>
</li>
<li><p>如果没有用赋值运算符显示赋值，则什么也不干(保留默认值)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static Leader leader;</div></pre></td></tr></table></figure>
<ul>
<li>即使这个属性所属的类尚未被装载，也不会去装载这个类lazy load</li>
</ul>
</li>
<li><p>如果static块中的语句会使用未装载的类，则先装载这个类，再执行这条语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static&#123;...&#125;</div></pre></td></tr></table></figure>
<ul>
<li>即使本类的所有方法(包括构造器)都会使用未装载的类，也不会导致类加载；直到这些方法真正被执行的时候，才会判断使用到的类是否已被装载lazy load</li>
</ul>
</li>
<li><p>static块的执行和static属性的初始化是用一个过程，执行的先后顺序只取决于他们在类中定义的顺序</p>
</li>
<li><p>父类的初始化在父类的装载过程中完成</p>
</li>
</ul>
<h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><ol>
<li>如果要构造的对象所属的类尚未被装载，先装载类</li>
<li>为非static属性分配存储空间并全部置默认值</li>
<li>调用父类constructor：如果这个类有父类，则先构造它的父类；否则继续<ul>
<li>如果显示通过super初始化父类，那么super必须是constructor的第一行代码</li>
<li>根据类装载的顺序，此时父类一定被装载过了</li>
</ul>
</li>
<li>初始化实例属性：按照<strong>类定义中的顺序</strong>，从上到下初始化非static属性</li>
<li>执行构造器中的其他代码，即super之外的所有代码</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类装载&quot;&gt;&lt;a href=&quot;#类装载&quot; class=&quot;headerlink&quot; title=&quot;类装载&quot;&gt;&lt;/a&gt;类装载&lt;/h2&gt;&lt;pre class=&quot;mermaid&quot;&gt;
graph LR

A(loading)--&gt;B(verifying)--&gt;C(prepari
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/%E4%BD%BF%E7%94%A8jvm%E5%B7%A5%E5%85%B7%E6%8E%92%E6%9F%A5%E6%95%85%E9%9A%9C/"/>
    <id>http://code.idea4j.com/2020/09/11/使用jvm工具排查故障/</id>
    <published>2020-09-11T10:46:51.712Z</published>
    <updated>2020-08-17T09:10:52.367Z</updated>
    
    <content type="html"><![CDATA[<p>jps</p>
<p>jmap -histo [pid] &gt; pp.txt //快照</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jps&lt;/p&gt;
&lt;p&gt;jmap -histo [pid] &amp;gt; pp.txt //快照&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/Java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"/>
    <id>http://code.idea4j.com/2020/09/11/Java性能调优工具/</id>
    <published>2020-09-11T10:45:48.657Z</published>
    <updated>2020-09-01T02:20:29.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java性能调优工具"><a href="#Java性能调优工具" class="headerlink" title="Java性能调优工具"></a>Java性能调优工具</h1><h2 id="Linux命令行工具"><a href="#Linux命令行工具" class="headerlink" title="Linux命令行工具"></a>Linux命令行工具</h2><h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]</div></pre></td></tr></table></figure>
<p><img src="https://gitee.com/idea4j/imagerep/raw/master/images/image-20200901095826286.png" alt="image-20200901095826286"></p>
<p>两大区域<strong>统计信息区</strong>和<strong>进程信息区</strong></p>
<h4 id="统计信息区"><a href="#统计信息区" class="headerlink" title="统计信息区"></a>统计信息区</h4><ul>
<li><p>第一行：任务队列信息，与<code>uptime</code>命令执行结果相同。</p>
<ul>
<li>09:58:07：系统当前时间</li>
<li>up 195 days, 23:28：主机已运行时间</li>
<li>5 users：用户连接数（不是用户数，who命令）</li>
<li>load average: 0.03, 0.09, 0.12：系统平均负载，统计最近1,5,15分钟的系统平均负载</li>
</ul>
<p><strong>补充</strong>：<code>uptime -V</code>可查询版本</p>
</li>
<li><p>第二行：进程信息</p>
<ul>
<li>Tasks: 128 total：进程总数</li>
<li>1 running：正在运行的进程数</li>
<li>127 sleeping：睡眠的进程数</li>
<li>0 stopped：停止的进程数</li>
<li>0 zombie：僵尸进程数</li>
</ul>
</li>
<li><p>第三行：CPU信息（当有多个CPU时，这些内容可能会超过两行）</p>
<ul>
<li>2.8us：用户空间所占CPU百分比</li>
<li>1.0sy：内核空间占用CPU百分比</li>
<li>0.0 ni：用户进程空间内改变过优先级的进程占用CPU百分比</li>
<li>96.3id：空闲CPU百分比</li>
<li>0.0 wa：等待输入输出的CPU时间百分比</li>
<li>0.0 hi：硬件CPU中断占用百分比</li>
<li>0.0 si：软中断占用百分比</li>
<li>0.0 st：虚拟机占用百分比</li>
</ul>
</li>
<li><p>第四行：内存信息（与第五行的信息类似与free命令）</p>
<ul>
<li>8010424 total：物理内存总量</li>
<li>6038816 used：已使用的内存总量</li>
<li>274220 free：空闲的内存总量（free+used=total）</li>
<li>1723692 buffers：用作内核缓存的内存量</li>
</ul>
</li>
<li><p>第五行：swap信息</p>
<ul>
<li>0total：交换分区总量</li>
<li>0used：已使用的交换分区总量</li>
<li>0free：空闲交换区总量</li>
<li>1663496cached Mem：缓冲的交换区总量，内存中的内容被换出到交换区，然后又被换入到内存，但是使用过的交换区没有被覆盖，交换区的这些内容已存在于内存中的交换区的大小，相应的内存再次被换出时可不必再对交换区写入。</li>
</ul>
</li>
</ul>
<h4 id="进程信息区"><a href="#进程信息区" class="headerlink" title="进程信息区"></a>进程信息区</h4><ul>
<li>PID:进程id</li>
<li>PPID:父进程id</li>
<li>RUSER:Real user name（看了好多，都是这样写，也不知道和user有什么区别，欢迎补充此处）</li>
<li>UID:进程所有者的id</li>
<li>USER:进程所有者的用户名</li>
<li>GROUP:进程所有者的组名</li>
<li>TTY:启动进程的终端名。不是从终端启动的进程则显示为?</li>
<li>PR:优先级</li>
<li>NI:nice值。负值表示高优先级，正值表示低优先级</li>
<li>P:最后使用的CPU，仅在多CPU环境下有意义</li>
<li>%CPU:上次更新到现在的CPU时间占用百分比</li>
<li>TIME:进程使用的CPU时间总计，单位秒</li>
<li>TIME+：进程所使用的CPU时间总计，单位1/100秒</li>
<li>%MEM:进程使用的物理内存百分比</li>
<li>VIRT:进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li>
<li>SWAP:进程使用的虚拟内存中被被换出的大小</li>
<li>RES:进程使用的、未被换出的物理内存的大小</li>
<li>CODE:可执行代码占用的物理内存大小</li>
<li>DATA:可执行代码以外的部分（数据段+栈）占用的物理内存大小</li>
<li>SHR:共享内存大小</li>
<li>nFLT:页面错误次数</li>
<li>nDRT:最后一次写入到现在，被修改过的页面数</li>
<li>S:进程状态（D=不可中断的睡眠状态，R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</li>
<li>COMMAND:命令名/行</li>
<li>WCHAN:若该进程在睡眠，则显示睡眠中的系统函数名</li>
<li>Flags:任务标志</li>
</ul>
<h3 id="top命令的使用"><a href="#top命令的使用" class="headerlink" title="top命令的使用"></a>top命令的使用</h3><h4 id="top使用格式"><a href="#top使用格式" class="headerlink" title="top使用格式"></a>top使用格式</h4><p>top [-] [d] [p] [q] [c] [C] [S] [s] [n]</p>
<h4 id="top参数说明"><a href="#top参数说明" class="headerlink" title="top参数说明"></a>top参数说明</h4><ul>
<li>d: 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。</li>
<li>p: 通过指定监控进程ID来仅仅监控某个进程的状态。</li>
<li>q: 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。</li>
<li>S: 指定累计模式</li>
<li>s: 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。</li>
<li>i: 使top不显示任何闲置或者僵死进程。</li>
<li>c: 显示整个命令行而不只是显示命令名</li>
</ul>
<h4 id="交互命令"><a href="#交互命令" class="headerlink" title="交互命令"></a>交互命令</h4><ul>
<li>Ctrl+L: 擦除并且重写屏幕。</li>
<li>h或者?: 显示帮助画面，给出一些简短的命令总结说明。</li>
<li>k: 终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号;如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。</li>
<li>i: 忽略闲置和僵死进程。这是一个开关式命令。</li>
<li>q: 退出程序。</li>
<li>r: 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。</li>
<li>S: 切换到累计模式。</li>
<li>s: 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。</li>
<li>f或者F: 从当前显示中添加或者删除项目。</li>
<li>o或者O: 改变显示项目的顺序。</li>
<li>l: 切换显示平均负载和启动时间信息。</li>
<li>m: 切换显示内存信息。</li>
<li>t: 切换显示进程和CPU状态信息。</li>
<li>c: 切换显示命令名称和完整命令行。</li>
<li>M: 根据驻留内存大小进行排序。</li>
<li>P: 根据CPU使用百分比大小进行排序。</li>
<li>T: 根据时间/累计时间进行排序。</li>
<li>W: 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。</li>
</ul>
<h3 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h3><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><h3 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java性能调优工具&quot;&gt;&lt;a href=&quot;#Java性能调优工具&quot; class=&quot;headerlink&quot; title=&quot;Java性能调优工具&quot;&gt;&lt;/a&gt;Java性能调优工具&lt;/h1&gt;&lt;h2 id=&quot;Linux命令行工具&quot;&gt;&lt;a href=&quot;#Linux命令行工具&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/GC%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/"/>
    <id>http://code.idea4j.com/2020/09/11/GC日志配置/</id>
    <published>2020-09-11T10:45:48.605Z</published>
    <updated>2020-09-11T08:40:20.047Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java 8</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">LOG_DIR=&quot;/tmp/logs&quot;</div><div class="line">JAVA_OPT_LOG=&quot; -verbose:gc&quot;</div><div class="line">JAVA_OPT_LOG=&quot;$&#123;JAVA_OPT_LOG&#125; -XX:+PrintGCDetails&quot;</div><div class="line">JAVA_OPT_LOG=&quot;$&#123;JAVA_OPT_LOG&#125; -XX:+PrintGCDateStamps&quot;</div><div class="line">JAVA_OPT_LOG=&quot;$&#123;JAVA_OPT_LOG&#125; -XX:+PrintGCApplicationStoppedTime&quot;</div><div class="line">JAVA_OPT_LOG=&quot;$&#123;JAVA_OPT_LOG&#125; -XX:+PrintTenuringDistribution&quot;</div><div class="line">JAVA_OPT_LOG=&quot;$&#123;JAVA_OPT_LOG&#125; -Xloggc:$&#123;LOG_DIR&#125;/gc_%p.log&quot;</div><div class="line">JAVA_OPT_OOM=&quot; -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=$&#123;LOG_DIR&#125; -XX:ErrorFile=$&#123;LOG_DIR&#125;/hs_error_pid%p.log &quot;</div><div class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT_LOG&#125; $&#123;JAVA_OPT_OOM&#125;&quot;</div><div class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -XX:-OmitStackTraceInFastThrow&quot;</div></pre></td></tr></table></figure>
<p>-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps<br>-XX:+PrintGCApplicationStoppedTime -XX:+PrintTenuringDistribution<br>-Xloggc:/tmp/logs/gc_%p.log -XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath=/tmp/logs -XX:ErrorFile=/tmp/logs/hs_error_pid%p.log<br>-XX:-OmitStackTraceInFastThrow</p>
<p><strong>Java 13</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">LOG_DIR=&quot;/tmp/logs&quot;</div><div class="line">JAVA_OPT_LOG=&quot; -verbose:gc&quot;</div><div class="line">JAVA_OPT_LOG=&quot;$&#123;JAVA_OPT_LOG&#125; -Xlog:gc,gc+ref=debug,gc+heap=debug,gc+age=trace:file=$&#123;LOG_DIR&#125;/gc_%p.log:tags,uptime,time,level&quot;</div><div class="line">JAVA_OPT_LOG=&quot;$&#123;JAVA_OPT_LOG&#125; -Xlog:safepoint:file=$&#123;LOG_DIR&#125;/safepoint_%p.log:tags,uptime,time,level&quot;</div><div class="line">JAVA_OPT_OOM=&quot; -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=$&#123;LOG_DIR&#125; -XX:ErrorFile=$&#123;LOG_DIR&#125;/hs_error_pid%p.log &quot;</div><div class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT_LOG&#125; $&#123;JAVA_OPT_OOM&#125;&quot;</div><div class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -XX:-OmitStackTraceInFastThrow&quot;</div><div class="line">echo $JAVA_OPT</div></pre></td></tr></table></figure>
<p>-verbose:gc -Xlog:gc,gc+ref=debug,gc+heap=debug,gc+age=trace:file<br>=/tmp/logs/gc<em>%p.log:tags,uptime,time,level -Xlog:safepoint:file=/tmp<br>/logs/safepoint</em>%p.log:tags,uptime,time,level -XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath=/tmp/logs -XX:ErrorFile=/tmp/logs/hs_error_pid%p.log<br>-XX:-OmitStackTraceInFastThrow</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Java 8&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/dubbo%E6%96%87%E6%A1%A3%E6%91%98%E6%8A%84/"/>
    <id>http://code.idea4j.com/2020/09/11/dubbo文档摘抄/</id>
    <published>2020-09-11T10:45:48.597Z</published>
    <updated>2020-08-20T01:48:43.934Z</updated>
    
    <content type="html"><![CDATA[<p>dubbo文档</p>
<p>Dubbo 提供了4种负载均衡实现，分别是：</p>
<ul>
<li>基于权重随机算法的 RandomLoadBalance；</li>
<li>基于最少活跃调用数算法的 LeastActiveLoadBalance；</li>
<li>基于 hash 一致性的 ConsistentHashLoadBalance；</li>
<li>基于加权轮询算法的 RoundRobinLoadBalance；</li>
</ul>
<p>在 Dubbo 中，所有负载均衡实现类均继承自 AbstractLoadBalance，该类实现了 LoadBalance 接口，并封装了一些公共的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty())</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 如果 invokers 列表中仅有一个 Invoker，直接返回即可，无需进行负载均衡</span></div><div class="line">    <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 调用 doSelect 方法进行负载均衡，该方法为抽象方法，由子类实现</span></div><div class="line">    <span class="keyword">return</span> doSelect(invokers, url, invocation);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="RandomLoadBalance"><a href="#RandomLoadBalance" class="headerlink" title="RandomLoadBalance"></a>RandomLoadBalance</h3><p>加权随机算法，算法思想：假如有一组服务器servers=[A,B,C]，他们对应的权重为weights[5,3,2],权重总和为10.现在把这些权重值平铺在一维坐标值上，[0, 5) 区间属于服务器 A，[5, 8) 区间属于服务器 B，[8, 10) 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 [0, 10) 之间的随机数，然后计算这个随机数会落到哪个区间上。比如数字3会落到服务器 A 对应的区间上，此时返回服务器 A 即可。权重越大的机器，在坐标轴上对应的区间范围就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务器被选中的次数比例接近其权重比例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"random"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = invokers.size();</div><div class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">// 下面这个循环有两个作用，第一是计算总权重 totalWeight，</span></div><div class="line">        <span class="comment">// 第二是检测每个服务提供者的权重是否相同</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</div><div class="line">            <span class="comment">// 累加权重</span></div><div class="line">            totalWeight += weight;</div><div class="line">            <span class="comment">// 检测当前服务提供者的权重与上一个服务提供者的权重是否相同，</span></div><div class="line">            <span class="comment">// 不相同的话，则将 sameWeight 置为 false。</span></div><div class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></div><div class="line">                    &amp;&amp; weight != getWeight(invokers.get(i - <span class="number">1</span>), invocation)) &#123;</div><div class="line">                sameWeight = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 下面的 if 分支主要用于获取随机数，并计算随机数落在哪个区间上</span></div><div class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</div><div class="line">            <span class="comment">// 随机获取一个 [0, totalWeight) 区间内的数字</span></div><div class="line">            <span class="keyword">int</span> offset = random.nextInt(totalWeight);</div><div class="line">            <span class="comment">// 循环让 offset 数减去服务提供者权重值，当 offset 小于0时，返回相应的 Invoker。</span></div><div class="line">            <span class="comment">// 举例说明一下，我们有 servers = [A, B, C]，weights = [5, 3, 2]，offset = 7。</span></div><div class="line">            <span class="comment">// 第一次循环，offset - 5 = 2 &gt; 0，即 offset &gt; 5，</span></div><div class="line">            <span class="comment">// 表明其不会落在服务器 A 对应的区间上。</span></div><div class="line">            <span class="comment">// 第二次循环，offset - 3 = -1 &lt; 0，即 5 &lt; offset &lt; 8，</span></div><div class="line">            <span class="comment">// 表明其会落在服务器 B 对应的区间上</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">                <span class="comment">// 让随机值 offset 减去权重值</span></div><div class="line">                offset -= getWeight(invokers.get(i), invocation);</div><div class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// 返回相应的 Invoker</span></div><div class="line">                    <span class="keyword">return</span> invokers.get(i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 如果所有服务提供者权重值相同，此时直接随机返回一个即可</span></div><div class="line">        <span class="keyword">return</span> invokers.get(random.nextInt(length));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="LeastActiveLoadBalance"><a href="#LeastActiveLoadBalance" class="headerlink" title="LeastActiveLoadBalance"></a>LeastActiveLoadBalance</h3><p>LeastActiveLoadBalance翻译过来是最小活跃数负载均衡。活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求。此时应优先将请求分配给该服务提供者。在具体实现中，每个服务提供者对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。除了最小活跃数，LeastActiveLoadBalance 在实现上还引入了权重值。所以准确的来说，LeastActiveLoadBalance 是基于加权最小活跃数算法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeastActiveLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"leastactive"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = invokers.size();</div><div class="line">        <span class="comment">// 最小的活跃数</span></div><div class="line">        <span class="keyword">int</span> leastActive = -<span class="number">1</span>;</div><div class="line">        <span class="comment">// 具有相同“最小活跃数”的服务者提供者（以下用 Invoker 代称）数量</span></div><div class="line">        <span class="keyword">int</span> leastCount = <span class="number">0</span>; </div><div class="line">        <span class="comment">// leastIndexs 用于记录具有相同“最小活跃数”的 Invoker 在 invokers 列表中的下标信息</span></div><div class="line">        <span class="keyword">int</span>[] leastIndexs = <span class="keyword">new</span> <span class="keyword">int</span>[length];</div><div class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 第一个最小活跃数的 Invoker 权重值，用于与其他具有相同最小活跃数的 Invoker 的权重进行对比，</span></div><div class="line">        <span class="comment">// 以检测是否“所有具有相同最小活跃数的 Invoker 的权重”均相等</span></div><div class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 遍历 invokers 列表</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</div><div class="line">            <span class="comment">// 获取 Invoker 对应的活跃数</span></div><div class="line">            <span class="keyword">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</div><div class="line">            <span class="comment">// 获取权重 - ⭐️</span></div><div class="line">            <span class="keyword">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);</div><div class="line">            <span class="comment">// 发现更小的活跃数，重新开始</span></div><div class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || active &lt; leastActive) &#123;</div><div class="line">            	<span class="comment">// 使用当前活跃数 active 更新最小活跃数 leastActive</span></div><div class="line">                leastActive = active;</div><div class="line">                <span class="comment">// 更新 leastCount 为 1</span></div><div class="line">                leastCount = <span class="number">1</span>;</div><div class="line">                <span class="comment">// 记录当前下标值到 leastIndexs 中</span></div><div class="line">                leastIndexs[<span class="number">0</span>] = i;</div><div class="line">                totalWeight = weight;</div><div class="line">                firstWeight = weight;</div><div class="line">                sameWeight = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 当前 Invoker 的活跃数 active 与最小活跃数 leastActive 相同 </span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123;</div><div class="line">            	<span class="comment">// 在 leastIndexs 中记录下当前 Invoker 在 invokers 集合中的下标</span></div><div class="line">                leastIndexs[leastCount++] = i;</div><div class="line">                <span class="comment">// 累加权重</span></div><div class="line">                totalWeight += weight;</div><div class="line">                <span class="comment">// 检测当前 Invoker 的权重与 firstWeight 是否相等，</span></div><div class="line">                <span class="comment">// 不相等则将 sameWeight 置为 false</span></div><div class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></div><div class="line">                    &amp;&amp; weight != firstWeight) &#123;</div><div class="line">                    sameWeight = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 当只有一个 Invoker 具有最小活跃数，此时直接返回该 Invoker 即可</span></div><div class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> invokers.get(leastIndexs[<span class="number">0</span>]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 有多个 Invoker 具有相同的最小活跃数，但它们之间的权重不同</span></div><div class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</div><div class="line">        	<span class="comment">// 随机生成一个 [0, totalWeight) 之间的数字</span></div><div class="line">            <span class="keyword">int</span> offsetWeight = random.nextInt(totalWeight);</div><div class="line">            <span class="comment">// 循环让随机数减去具有最小活跃数的 Invoker 的权重值，</span></div><div class="line">            <span class="comment">// 当 offset 小于等于0时，返回相应的 Invoker</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</div><div class="line">                <span class="keyword">int</span> leastIndex = leastIndexs[i];</div><div class="line">                <span class="comment">// 获取权重值，并让随机数减去权重值 - ⭐️</span></div><div class="line">                offsetWeight -= getWeight(invokers.get(leastIndex), invocation);</div><div class="line">                <span class="keyword">if</span> (offsetWeight &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> invokers.get(leastIndex);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果权重相同或权重为0时，随机返回一个 Invoker</span></div><div class="line">        <span class="keyword">return</span> invokers.get(leastIndexs[random.nextInt(leastCount)]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大致的实现逻辑:</p>
<ol>
<li>遍历 invokers 列表，寻找活跃数最小的 Invoker</li>
<li>如果有多个 Invoker 具有相同的最小活跃数，此时记录下这些 Invoker 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等</li>
<li>如果只有一个 Invoker 具有最小的活跃数，此时直接返回该 Invoker 即可</li>
<li>如果有多个 Invoker 具有最小活跃数，且它们的权重不相等，此时处理方式和 RandomLoadBalance 一致</li>
<li>如果有多个 Invoker 具有最小活跃数，但它们的权重相等，此时随机返回一个即可</li>
</ol>
<h3 id="ConsistentHashLoadBalance"><a href="#ConsistentHashLoadBalance" class="headerlink" title="ConsistentHashLoadBalance"></a>ConsistentHashLoadBalance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = </div><div class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</div><div class="line">        String methodName = RpcUtils.getMethodName(invocation);</div><div class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + methodName;</div><div class="line"></div><div class="line">        <span class="comment">// 获取 invokers 原始的 hashcode</span></div><div class="line">        <span class="keyword">int</span> identityHashCode = System.identityHashCode(invokers);</div><div class="line">        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</div><div class="line">        <span class="comment">// 如果 invokers 是一个新的 List 对象，意味着服务提供者数量发生了变化，可能新增也可能减少了。</span></div><div class="line">        <span class="comment">// 此时 selector.identityHashCode != identityHashCode 条件成立</span></div><div class="line">        <span class="keyword">if</span> (selector == <span class="keyword">null</span> || selector.identityHashCode != identityHashCode) &#123;</div><div class="line">            <span class="comment">// 创建新的 ConsistentHashSelector</span></div><div class="line">            selectors.put(key, <span class="keyword">new</span> ConsistentHashSelector&lt;T&gt;(invokers, methodName, identityHashCode));</div><div class="line">            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 调用 ConsistentHashSelector 的 select 方法选择 Invoker</span></div><div class="line">        <span class="keyword">return</span> selector.select(invocation);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashSelector</span>&lt;<span class="title">T</span>&gt; </span>&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="RoundRobinLoadBalance"><a href="#RoundRobinLoadBalance" class="headerlink" title="RoundRobinLoadBalance"></a>RoundRobinLoadBalance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"roundrobin"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, AtomicPositiveInteger&gt; sequences = </div><div class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</div><div class="line">        <span class="comment">// key = 全限定类名 + "." + 方法名，比如 com.xxx.DemoService.sayHello</span></div><div class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + invocation.getMethodName();</div><div class="line">        <span class="keyword">int</span> length = invokers.size();</div><div class="line">        <span class="comment">// 最大权重</span></div><div class="line">        <span class="keyword">int</span> maxWeight = <span class="number">0</span>;</div><div class="line">        <span class="comment">// 最小权重</span></div><div class="line">        <span class="keyword">int</span> minWeight = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">final</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; invokerToWeightMap = <span class="keyword">new</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt;();</div><div class="line">        <span class="comment">// 权重总和</span></div><div class="line">        <span class="keyword">int</span> weightSum = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 下面这个循环主要用于查找最大和最小权重，计算权重总和等</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">            <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</div><div class="line">            <span class="comment">// 获取最大和最小权重</span></div><div class="line">            maxWeight = Math.max(maxWeight, weight);</div><div class="line">            minWeight = Math.min(minWeight, weight);</div><div class="line">            <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 将 weight 封装到 IntegerWrapper 中</span></div><div class="line">                invokerToWeightMap.put(invokers.get(i), <span class="keyword">new</span> IntegerWrapper(weight));</div><div class="line">                <span class="comment">// 累加权重</span></div><div class="line">                weightSum += weight;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 查找 key 对应的对应 AtomicPositiveInteger 实例，为空则创建。</span></div><div class="line">        <span class="comment">// 这里可以把 AtomicPositiveInteger 看成一个黑盒，大家只要知道</span></div><div class="line">        <span class="comment">// AtomicPositiveInteger 用于记录服务的调用编号即可。至于细节，</span></div><div class="line">        <span class="comment">// 大家如果感兴趣，可以自行分析</span></div><div class="line">        AtomicPositiveInteger sequence = sequences.get(key);</div><div class="line">        <span class="keyword">if</span> (sequence == <span class="keyword">null</span>) &#123;</div><div class="line">            sequences.putIfAbsent(key, <span class="keyword">new</span> AtomicPositiveInteger());</div><div class="line">            sequence = sequences.get(key);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 获取当前的调用编号</span></div><div class="line">        <span class="keyword">int</span> currentSequence = sequence.getAndIncrement();</div><div class="line">        <span class="comment">// 如果最小权重小于最大权重，表明服务提供者之间的权重是不相等的</span></div><div class="line">        <span class="keyword">if</span> (maxWeight &gt; <span class="number">0</span> &amp;&amp; minWeight &lt; maxWeight) &#123;</div><div class="line">            <span class="comment">// 使用调用编号对权重总和进行取余操作</span></div><div class="line">            <span class="keyword">int</span> mod = currentSequence % weightSum;</div><div class="line">            <span class="comment">// 进行 maxWeight 次遍历</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxWeight; i++) &#123;</div><div class="line">                <span class="comment">// 遍历 invokerToWeightMap</span></div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; each : invokerToWeightMap.entrySet()) &#123;</div><div class="line">					<span class="comment">// 获取 Invoker</span></div><div class="line">                    <span class="keyword">final</span> Invoker&lt;T&gt; k = each.getKey();</div><div class="line">                    <span class="comment">// 获取权重包装类 IntegerWrapper</span></div><div class="line">                    <span class="keyword">final</span> IntegerWrapper v = each.getValue();</div><div class="line">                    </div><div class="line">                    <span class="comment">// 如果 mod = 0，且权重大于0，此时返回相应的 Invoker</span></div><div class="line">                    <span class="keyword">if</span> (mod == <span class="number">0</span> &amp;&amp; v.getValue() &gt; <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> k;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    <span class="comment">// mod != 0，且权重大于0，此时对权重和 mod 分别进行自减操作</span></div><div class="line">                    <span class="keyword">if</span> (v.getValue() &gt; <span class="number">0</span>) &#123;</div><div class="line">                        v.decrement();</div><div class="line">                        mod--;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 服务提供者之间的权重相等，此时通过轮询选择 Invoker</span></div><div class="line">        <span class="keyword">return</span> invokers.get(currentSequence % length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// IntegerWrapper 是一个 int 包装类，主要包含了一个自减方法。</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerWrapper</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.value--;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 省略部分代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dubbo文档&lt;/p&gt;
&lt;p&gt;Dubbo 提供了4种负载均衡实现，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于权重随机算法的 RandomLoadBalance；&lt;/li&gt;
&lt;li&gt;基于最少活跃调用数算法的 LeastActiveLoadBalance；&lt;/li&gt;
&lt;li&gt;基于
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/dubbo%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://code.idea4j.com/2020/09/11/dubbo架构设计/</id>
    <published>2020-09-11T10:45:48.576Z</published>
    <updated>2020-08-24T06:28:32.338Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dubbo架构设计"><a href="#dubbo架构设计" class="headerlink" title="dubbo架构设计"></a>dubbo架构设计</h3><p><img src="https://gitee.com/idea4j/imagerep/raw/master/images/image-20200821100631881.png" alt="image-20200821100631881"></p>
<p>淡蓝色是服务提供者使用到的接口，淡绿色是服务消费者使用接口，中轴线上是双方都用到的接口。</p>
<p>从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表之间的依赖关系，每一层都可以剥离上层被复用，其中，Service和Config层为API，其他各层均为SPI。</p>
<p>绿色小块的为扩展接口，蓝色小块为实现类</p>
<p>蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行是调用链，紫色三角箭头为继承</p>
<p>config配置层：对外配置接口，以ServiceConfig,ReferenceConfig为中心，可以直接初始化配置类，也可以通过spring解析配置生成配置类</p>
<p>proxy服务代理层</p>
<p>registry注册中心层</p>
<p>cluster路由层</p>
<p>monitor监控层</p>
<p>ptotocol远程调用层</p>
<p>exchange信息交换层</p>
<p>transport网络传输层</p>
<p>serialize 数据序列化层</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;dubbo架构设计&quot;&gt;&lt;a href=&quot;#dubbo架构设计&quot; class=&quot;headerlink&quot; title=&quot;dubbo架构设计&quot;&gt;&lt;/a&gt;dubbo架构设计&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/idea4j/imagere
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/MAT%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8%E4%B9%8B%E6%B7%B1%E5%A0%86%E5%92%8C%E6%B5%85%E5%A0%86/"/>
    <id>http://code.idea4j.com/2020/09/11/MAT工具应用之深堆和浅堆/</id>
    <published>2020-09-11T10:45:48.558Z</published>
    <updated>2020-09-08T06:38:23.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MAT工具应用之深堆和浅堆"><a href="#MAT工具应用之深堆和浅堆" class="headerlink" title="MAT工具应用之深堆和浅堆"></a>MAT工具应用之深堆和浅堆</h2><h3 id="浅堆（Shallow-Heap）"><a href="#浅堆（Shallow-Heap）" class="headerlink" title="浅堆（Shallow Heap）"></a>浅堆（Shallow Heap）</h3><p>浅堆是指一个对象所消耗的内存（对象头+实例数据+对齐填充，不包括内部引用对象大小）</p>
<p>32位操作系统中<br>一个对象的对象头占用8字节，对象中的一个引用占4个字节，需要补齐位8的倍数<br>一维数组的为特殊对象，对象头占8个字节，加上4字节的长度数量，加上数组长度N*数组类型<br>String类型占用的字节数位40+2N+pandding（补齐为8的个数）</p>
<p>64位操作系统中<br>一个对象的对象头占用16字节，对象中的一个引用占8个字节，需要补齐位8的倍数<br>一维数组的为特殊对象，对象头占16个字节，加上8字节的长度数量，加上数组长度N*数组类型<br>String类型占用的字节数位64+2N+pandding（补齐为8的个数）</p>
<h3 id="深堆（Retained-Heap）"><a href="#深堆（Retained-Heap）" class="headerlink" title="深堆（Retained Heap）"></a>深堆（Retained Heap）</h3><p>深堆表示一个对象被 GC 回收后，可以真实释放的内存大小（保留空间）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.idea4j.jvm.mat;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.idea4j.jvm.mat;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Line</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Point startPoint;<span class="comment">//</span></div><div class="line">    <span class="keyword">private</span> Point endPoint;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Line</span><span class="params">(Point startPoint, Point endPoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.startPoint = startPoint;</div><div class="line">        <span class="keyword">this</span>.endPoint = endPoint;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getStartPoint</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> startPoint;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartPoint</span><span class="params">(Point startPoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.startPoint = startPoint;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getEndPoint</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> endPoint;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEndPoint</span><span class="params">(Point endPoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.endPoint = endPoint;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.idea4j.jvm.mat;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowRetainedDump</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">        Point a = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        Point b = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">        Point c = <span class="keyword">new</span> Point(<span class="number">5</span>, <span class="number">3</span>);</div><div class="line">        Point d = <span class="keyword">new</span> Point(<span class="number">9</span>, <span class="number">8</span>);</div><div class="line">        Point e = <span class="keyword">new</span> Point(<span class="number">6</span>, <span class="number">7</span>);</div><div class="line">        Point f = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">9</span>);</div><div class="line">        Point g = <span class="keyword">new</span> Point(<span class="number">4</span>, <span class="number">8</span>);</div><div class="line"></div><div class="line">        Line aLine = <span class="keyword">new</span> Line(a, b);</div><div class="line">        Line bLine = <span class="keyword">new</span> Line(a, c);</div><div class="line">        Line cLine = <span class="keyword">new</span> Line(d, e);</div><div class="line">        Line dLine = <span class="keyword">new</span> Line(f, g);</div><div class="line">        a = <span class="keyword">null</span>;</div><div class="line">        b = <span class="keyword">null</span>;</div><div class="line">        c = <span class="keyword">null</span>;</div><div class="line">        d = <span class="keyword">null</span>;</div><div class="line">        e = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">1000000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/idea4j/imagerep/raw/master/images/image-20200828200917670.png" alt="image-20200828200917670"></h3><p>如图（64位机器下），按照上面提到的  Line对象有两个Point对象组成 ,所以Line的浅</p>
<p>浅堆的大小为：对象头（16）+ 两个对象引用（8*2）=32，与图中数值不符。这是为什么呢？</p>
<p>这里是开启了指针压缩，开启指针压缩后，对象头占用字节为14，对象引用占用字节为4，那么，</p>
<p>浅堆的大小为：对象头（12）+ 两个对象引用（4*2）= 20，20不是8的倍数需要补齐，所以浅堆的大小为24.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">* -XX:+UseCompressedOops开启指针压缩（默认） oop对象指针</div><div class="line">* -XX:-UseCompressedOops关闭指针压缩</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MAT工具应用之深堆和浅堆&quot;&gt;&lt;a href=&quot;#MAT工具应用之深堆和浅堆&quot; class=&quot;headerlink&quot; title=&quot;MAT工具应用之深堆和浅堆&quot;&gt;&lt;/a&gt;MAT工具应用之深堆和浅堆&lt;/h2&gt;&lt;h3 id=&quot;浅堆（Shallow-Heap）&quot;&gt;&lt;a 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/zookeeper%E7%9B%B8%E5%85%B3/"/>
    <id>http://code.idea4j.com/2020/09/11/zookeeper相关/</id>
    <published>2020-09-11T10:45:15.863Z</published>
    <updated>2020-08-11T08:04:24.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper相关"><a href="#zookeeper相关" class="headerlink" title="zookeeper相关"></a>zookeeper相关</h1><h2 id="ZooKeeper-是什么？"><a href="#ZooKeeper-是什么？" class="headerlink" title="ZooKeeper 是什么？"></a>ZooKeeper 是什么？</h2><p>​    ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>
<p>​    ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
<p>Zookeeper 保证了如下分布式一致性特性：</p>
<ol>
<li>顺序一致性</li>
<li>原子性</li>
<li>单一视图</li>
<li>可靠性</li>
<li>实时性（最终一致性）</li>
</ol>
<p>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。</p>
<p>有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper 最新的 zxid。</p>
<h2 id="ZooKeeper-提供了什么？"><a href="#ZooKeeper-提供了什么？" class="headerlink" title="ZooKeeper 提供了什么？"></a>ZooKeeper 提供了什么？</h2><ul>
<li>文件系统</li>
<li>通知机制</li>
</ul>
<h2 id="Zookeeper-文件系统"><a href="#Zookeeper-文件系统" class="headerlink" title="Zookeeper 文件系统"></a>Zookeeper 文件系统</h2><p>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。</p>
<p>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M。</p>
<h2 id="Zookeeper-怎么保证主从节点的状态同步？"><a href="#Zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="Zookeeper 怎么保证主从节点的状态同步？"></a>Zookeeper 怎么保证主从节点的状态同步？</h2><p>Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p>
<p>恢复模式当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
<p>广播模式一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个 server 加入 ZooKeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。</p>
<h2 id="四种类型的数据节点-Znode"><a href="#四种类型的数据节点-Znode" class="headerlink" title="四种类型的数据节点 Znode"></a>四种类型的数据节点 Znode</h2><p>（1）PERSISTENT-持久节点</p>
<p>除非手动删除，否则节点一直存在于 Zookeeper 上</p>
<p>（2）EPHEMERAL-临时节点</p>
<p>临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</p>
<p>（3）PERSISTENT_SEQUENTIAL-持久顺序节点</p>
<p>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p>
<p>（4）EPHEMERAL_SEQUENTIAL-临时顺序节点</p>
<p>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p>
<h2 id="Zookeeper-Watcher-机制-–-数据变更通知"><a href="#Zookeeper-Watcher-机制-–-数据变更通知" class="headerlink" title="Zookeeper Watcher 机制 – 数据变更通知"></a>Zookeeper Watcher 机制 – 数据变更通知</h2><p>Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。</p>
<p>工作机制：</p>
<p>（1）客户端注册 watcher</p>
<p>（2）服务端处理 watcher</p>
<p>（3）客户端回调 watcher</p>
<p>Watcher 特性总结：</p>
<p>（1）一次性</p>
<p>无论是服务端还是客户端，一旦一个 Watcher 被 触 发 ，Zookeeper 都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。</p>
<p>（2）客户端串行执行</p>
<p>客户端 Watcher 回调的过程是一个串行同步的过程。</p>
<p>（3）轻量</p>
<p>3.1、Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。</p>
<p>3.2、客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记。</p>
<p>（4）watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是异步的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于 Zookeeper 本身提供了 ordering guarantee，即客户端监听事件后，才会感知它所监视 znode发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。Zookeeper 只能保证最终的一致性，而无法保证强一致性。</p>
<p>（5）注册 watcher getData、exists、getChildren</p>
<p>（6）触发 watcher create、delete、setData</p>
<p>（7）当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 watch 事件可能会被丢失。</p>
<h2 id="客户端注册-Watcher-实现"><a href="#客户端注册-Watcher-实现" class="headerlink" title="客户端注册 Watcher 实现"></a>客户端注册 Watcher 实现</h2><p>（1）调用 getData()/getChildren()/exist()三个 API，传入 Watcher 对象</p>
<p>（2）标记请求 request，封装 Watcher 到 WatchRegistration</p>
<p>（3）封装成 Packet 对象，发服务端发送 request</p>
<p>（4）收到服务端响应后，将 Watcher 注册到 ZKWatcherManager 中进行管理</p>
<p>（5）请求返回，完成注册。</p>
<h2 id="服务端处理-Watcher-实现"><a href="#服务端处理-Watcher-实现" class="headerlink" title="服务端处理 Watcher 实现"></a>服务端处理 Watcher 实现</h2><h2 id="客户端回调-Watcher"><a href="#客户端回调-Watcher" class="headerlink" title="客户端回调 Watcher"></a>客户端回调 Watcher</h2><h2 id="ACL-权限控制机制"><a href="#ACL-权限控制机制" class="headerlink" title="ACL 权限控制机制"></a>ACL 权限控制机制</h2><h2 id="Chroot-特性"><a href="#Chroot-特性" class="headerlink" title="Chroot 特性"></a>Chroot 特性</h2><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><h2 id="服务器角色"><a href="#服务器角色" class="headerlink" title="服务器角色"></a>服务器角色</h2><h2 id="Zookeeper-下-Server-工作状态"><a href="#Zookeeper-下-Server-工作状态" class="headerlink" title="Zookeeper 下 Server 工作状态"></a>Zookeeper 下 Server 工作状态</h2><p>服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。</p>
<p>（1）LOOKING：寻 找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</p>
<p>（2）FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。</p>
<p>（3）LEADING：领导者状态。表明当前服务器角色是 Leader。</p>
<p>（4）OBSERVING：观察者状态。表明当前服务器角色是 Observer。</p>
<h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><h2 id="zookeeper-是如何保证事务的顺序一致性的？"><a href="#zookeeper-是如何保证事务的顺序一致性的？" class="headerlink" title="zookeeper 是如何保证事务的顺序一致性的？"></a>zookeeper 是如何保证事务的顺序一致性的？</h2><p>zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（ 时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p>
<h2 id="分布式集群中为什么会有-Master主节点？"><a href="#分布式集群中为什么会有-Master主节点？" class="headerlink" title="分布式集群中为什么会有 Master主节点？"></a>分布式集群中为什么会有 Master主节点？</h2><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 leader 选举。</p>
<h2 id="zk-节点宕机如何处理？"><a href="#zk-节点宕机如何处理？" class="headerlink" title="zk 节点宕机如何处理？"></a>zk 节点宕机如何处理？</h2><p>Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。</p>
<p>如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；</p>
<p>如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</p>
<p>ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。</p>
<p>所以</p>
<p>3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5)</p>
<p>2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;=1)</p>
<h2 id="zookeeper-负载均衡和-nginx-负载均衡区别"><a href="#zookeeper-负载均衡和-nginx-负载均衡区别" class="headerlink" title="zookeeper 负载均衡和 nginx 负载均衡区别"></a>zookeeper 负载均衡和 nginx 负载均衡区别</h2><p>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写插件；但是 nginx 的吞吐量比 zk 大很多，应该说按业务选择用哪种方式。</p>
<h2 id="Zookeeper-有哪几种几种部署模式？"><a href="#Zookeeper-有哪几种几种部署模式？" class="headerlink" title="Zookeeper 有哪几种几种部署模式？"></a>Zookeeper 有哪几种几种部署模式？</h2><h2 id="集群最少要几台机器，集群规则是怎样的？集群中有-3-台服务器，其中一个节点宕机，这个时候-Zookeeper-还可以使用吗？"><a href="#集群最少要几台机器，集群规则是怎样的？集群中有-3-台服务器，其中一个节点宕机，这个时候-Zookeeper-还可以使用吗？" class="headerlink" title="集群最少要几台机器，集群规则是怎样的？集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？"></a>集群最少要几台机器，集群规则是怎样的？集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？</h2><h2 id="集群支持动态添加机器吗？"><a href="#集群支持动态添加机器吗？" class="headerlink" title="集群支持动态添加机器吗？"></a>集群支持动态添加机器吗？</h2><h2 id="Zookeeper-对节点的-watch-监听通知是永久的吗？为什么不是永久的"><a href="#Zookeeper-对节点的-watch-监听通知是永久的吗？为什么不是永久的" class="headerlink" title="Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?"></a>Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?</h2><h2 id="Zookeeper-的-java-客户端都有哪些？"><a href="#Zookeeper-的-java-客户端都有哪些？" class="headerlink" title="Zookeeper 的 java 客户端都有哪些？"></a>Zookeeper 的 java 客户端都有哪些？</h2><p>java 客户端：zk 自带的 zkclient 及 Apache 开源的 Curator。</p>
<h2 id="chubby-是什么，和-zookeeper-比你怎么看？"><a href="#chubby-是什么，和-zookeeper-比你怎么看？" class="headerlink" title="chubby 是什么，和 zookeeper 比你怎么看？"></a>chubby 是什么，和 zookeeper 比你怎么看？</h2><h2 id="说几个-zookeeper-常用的命令。"><a href="#说几个-zookeeper-常用的命令。" class="headerlink" title="说几个 zookeeper 常用的命令。"></a>说几个 zookeeper 常用的命令。</h2><p>常用命令：ls get set create delete 等。</p>
<h2 id="ZAB-和-Paxos-算法的联系与区别？"><a href="#ZAB-和-Paxos-算法的联系与区别？" class="headerlink" title="ZAB 和 Paxos 算法的联系与区别？"></a>ZAB 和 Paxos 算法的联系与区别？</h2><p>相同点：</p>
<p>（1）两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行</p>
<p>（2）Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交</p>
<p>（3）ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 Leader周期，Paxos 中名字为 Ballot</p>
<p>不同点：</p>
<p>ZAB 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建分布式一致性状态机系统</p>
<h2 id="Zookeeper-的典型应用场景"><a href="#Zookeeper-的典型应用场景" class="headerlink" title="Zookeeper 的典型应用场景"></a>Zookeeper 的典型应用场景</h2><h2 id="Zookeeper-都有哪些功能？"><a href="#Zookeeper-都有哪些功能？" class="headerlink" title="Zookeeper 都有哪些功能？"></a>Zookeeper 都有哪些功能？</h2><h2 id="说一下-Zookeeper-的通知机制？"><a href="#说一下-Zookeeper-的通知机制？" class="headerlink" title="说一下 Zookeeper 的通知机制？"></a>说一下 Zookeeper 的通知机制？</h2><h2 id="Zookeeper-和-Dubbo-的关系？"><a href="#Zookeeper-和-Dubbo-的关系？" class="headerlink" title="Zookeeper 和 Dubbo 的关系？"></a>Zookeeper 和 Dubbo 的关系？</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;zookeeper相关&quot;&gt;&lt;a href=&quot;#zookeeper相关&quot; class=&quot;headerlink&quot; title=&quot;zookeeper相关&quot;&gt;&lt;/a&gt;zookeeper相关&lt;/h1&gt;&lt;h2 id=&quot;ZooKeeper-是什么？&quot;&gt;&lt;a href=&quot;#Zoo
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/zookeeper%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99/"/>
    <id>http://code.idea4j.com/2020/09/11/zookeeper选举规则/</id>
    <published>2020-09-11T10:45:15.835Z</published>
    <updated>2020-08-31T12:20:26.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="zookeeper选举规则"><a href="#zookeeper选举规则" class="headerlink" title="zookeeper选举规则"></a>zookeeper选举规则</h3><p>角色：</p>
<p>1.LOOKING：竞选</p>
<p>​      2.OBSERVING：观察</p>
<p>​      3.FOLLOWING：跟随者</p>
<p>​      4.LEADER：领导者</p>
<p>投票信息：</p>
<p>​      1.logicalclock（electionEpoch）：本地选举周期，每次投票都会自增</p>
<p>​      2.epoch（peerEpoch）：选举周期，每次选举最终确定完leader结束选举流程时会自增(真正zxid的前32位)</p>
<p>​      3.zxid：数据ID，每次数据变动都会自增（真正zxid的后32位，zxid一共64位）</p>
<p>​      4.sid：该投票信息所属的serverId</p>
<p>​      5.leader：提议的leader（被提议的server的serverId，即sid）</p>
<p>没有leader时</p>
<p>投票比较规则：</p>
<p>​     1.epoch大的胜出，否则进行步骤2</p>
<p>​     2.zxid大的胜出，否则进行步骤3</p>
<p>​     3.sid大的胜出</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;zookeeper选举规则&quot;&gt;&lt;a href=&quot;#zookeeper选举规则&quot; class=&quot;headerlink&quot; title=&quot;zookeeper选举规则&quot;&gt;&lt;/a&gt;zookeeper选举规则&lt;/h3&gt;&lt;p&gt;角色：&lt;/p&gt;
&lt;p&gt;1.LOOKING：竞选&lt;/p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/%E7%BC%93%E5%AD%98/"/>
    <id>http://code.idea4j.com/2020/09/11/缓存/</id>
    <published>2020-09-11T05:53:44.773Z</published>
    <updated>2020-09-11T05:53:44.773Z</updated>
    
    <content type="html"><![CDATA[<p>– 缓存</p>
<p>源码</p>
<p>– dubbo</p>
<p>spring</p>
<p>redis</p>
<p>HashMap</p>
<p>jdk</p>
<p>分布式</p>
<p>– 多线程 原理</p>
<p>jvm</p>
<p>rpc</p>
<p>流式</p>
<p>分析数据库</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;– 缓存&lt;/p&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;p&gt;– dubbo&lt;/p&gt;
&lt;p&gt;spring&lt;/p&gt;
&lt;p&gt;redis&lt;/p&gt;
&lt;p&gt;HashMap&lt;/p&gt;
&lt;p&gt;jdk&lt;/p&gt;
&lt;p&gt;分布式&lt;/p&gt;
&lt;p&gt;– 多线程 原理&lt;/p&gt;
&lt;p&gt;jvm&lt;/p&gt;
&lt;p&gt;rpc&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>http://code.idea4j.com/2020/09/11/类加载/</id>
    <published>2020-09-11T05:53:44.772Z</published>
    <updated>2020-09-11T05:53:44.772Z</updated>
    
    <content type="html"><![CDATA[<p>类加载</p>
<p>类的生命周期</p>
<pre class="mermaid">graph LR

A(加载<br>loading) --> B(验证<br>Verification)--> C(准备<br>Preparation)-->D(解析<br>Resolution)-->E(初始化<br>Initialization)-->F(使用<br>Using)-->G(卸载<br>Unloading)</pre>



<ol>
<li>虚拟机规范严格规定了有且只有5中情况必须立即对类进行初始化（而加载、验证、准备自然要在此之前）：</li>
<li>遇到new、getstatic、putstatic、或invokestatic这4条指令是，如果类没有进行过初始化，则先触发初始化。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要先触发初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有初始化，则要先触发其父类初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会初始化这个主类。</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则要先触发初始化。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类加载&lt;/p&gt;
&lt;p&gt;类的生命周期&lt;/p&gt;
&lt;pre class=&quot;mermaid&quot;&gt;graph LR

A(加载&lt;br&gt;loading) --&gt; B(验证&lt;br&gt;Verification)--&gt; C(准备&lt;br&gt;Preparation)--&gt;D(解析&lt;br&gt;Resolut
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/%E6%B7%B1%E5%85%8B%E9%9A%86%E5%92%8C%E6%B5%85%E5%85%8B%E9%9A%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>http://code.idea4j.com/2020/09/11/深克隆和浅克隆有什么区别/</id>
    <published>2020-09-11T05:53:44.770Z</published>
    <updated>2020-09-11T05:53:44.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深克隆和浅克隆有什么区别"><a href="#深克隆和浅克隆有什么区别" class="headerlink" title="深克隆和浅克隆有什么区别"></a>深克隆和浅克隆有什么区别</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深克隆和浅克隆有什么区别&quot;&gt;&lt;a href=&quot;#深克隆和浅克隆有什么区别&quot; class=&quot;headerlink&quot; title=&quot;深克隆和浅克隆有什么区别&quot;&gt;&lt;/a&gt;深克隆和浅克隆有什么区别&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/%E6%8E%92%E5%BA%8F/"/>
    <id>http://code.idea4j.com/2020/09/11/排序/</id>
    <published>2020-09-11T05:53:44.768Z</published>
    <updated>2020-09-11T05:53:44.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="基于比较的排序算法"><a href="#基于比较的排序算法" class="headerlink" title="基于比较的排序算法:"></a>基于比较的排序算法:</h2><h3 id="BUB-冒泡排序"><a href="#BUB-冒泡排序" class="headerlink" title="BUB - 冒泡排序"></a>BUB - 冒泡排序</h3><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>1.比较相邻的元素，如果第一个比第二个大，就交换他们两个；</p>
<p>2.对每一对相邻的元素做同样的工作，从开始第一对到结尾的最后一对，比较完一轮，最大的元素就放到了最后一位；</p>
<p>3.针对所有元素重复以上步骤，除了最后一个；</p>
<p>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较；</p>
<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：$C<em>{min}=n-1$,$M</em>{min}=0$</p>
<p>所以，冒泡排序最好的时间复杂度为O(n)。</p>
<p>若初始文件是反序的，需要进行$n-1$趟排序。每趟排序要进行$n-i$次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p>
<p>$$<br>C_{max}=\frac{n(n-1)}{2}=O(n^2)<br>$$</p>
<p>$$<br>M_{max}=\frac{3n(n-1)}{2}=O(n^2)<br>$$</p>
<p>冒泡排序的最坏时间复杂度为:$O(n^2)$.</p>
<p>因此冒泡排序的总的平均时间复杂度为$O(n^2)$.</p>
<h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;aar.length;i++)&#123;</div><div class="line">    <span class="keyword">boolean</span> isSwap = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//从第一位和第二位开始比较，每一轮最大的数都排到了最后</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;aar.length-i-<span class="number">1</span>;j++)&#123;</div><div class="line">      <span class="comment">//如果前面的元素大于后面的元素，交换位置</span></div><div class="line">      <span class="keyword">if</span>(arr[j]&gt;arr&#123;j+<span class="number">1</span>&#125;)&#123;</div><div class="line">        <span class="keyword">int</span> temp = arr[j];</div><div class="line">        arr[j] = arr[j+<span class="number">1</span>];</div><div class="line">        arr[j+<span class="number">1</span>]=temp;</div><div class="line">        isSwap = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果没有换位，说明排序完成了</span></div><div class="line">    <span class="keyword">if</span>(!isSwap)&#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SEL-选择排序"><a href="#SEL-选择排序" class="headerlink" title="SEL - 选择排序"></a>SEL - 选择排序</h3><h4 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h4><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><h5 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h5><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">           <span class="keyword">int</span> min = i;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; a.length; j++) &#123;</div><div class="line">               <span class="keyword">if</span> (a[min] &gt; a[j]) &#123;</div><div class="line">                   min=j;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (min != i) &#123;</div><div class="line">               <span class="keyword">int</span> temp = a[min];</div><div class="line">               a[min] = a[i];</div><div class="line">               a[i] = temp;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="INS-插入排序"><a href="#INS-插入排序" class="headerlink" title="INS - 插入排序"></a>INS - 插入排序</h3><h4 id="算法原理-2"><a href="#算法原理-2" class="headerlink" title="算法原理"></a>算法原理</h4><p>将第一个元素标记为已排序</p>
<p>遍历每个没有排序过的元素</p>
<p> “提取” 元素 X</p>
<p> i = 最后排序过元素的指数 到 0 的遍历</p>
<p>  如果现在排序过的元素 &gt; 提取的元素</p>
<p>   将排序过的元素向右移一格</p>
<p>  否则：插入提取的元素</p>
<h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><h5 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><h5 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h5><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length ; i++) &#123;</div><div class="line">            <span class="comment">//第一个元素为一个有序部分，故而，从数组第二个元素提取</span></div><div class="line">            <span class="keyword">int</span> value = a[i];</div><div class="line">            <span class="comment">//依次和有序部分从后往前比较，</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;<span class="number">0</span>; j--) &#123;</div><div class="line">                <span class="comment">//如果取出的元素小于有序部分的元素，</span></div><div class="line">                <span class="keyword">if</span> (a[j] &gt; value) &#123;</div><div class="line">                    <span class="comment">//那么有序部分的元素往后移动一位 即有序部分下标+1</span></div><div class="line">                    a[j+<span class="number">1</span>] = a[j];</div><div class="line">                    <span class="comment">//否则结束比较，提取元素插入最后移动的哪个元素的位置</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    a[j+<span class="number">1</span>] = value;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="MER-归并排序-递归实现"><a href="#MER-归并排序-递归实现" class="headerlink" title="MER - 归并排序 (递归实现)"></a>MER - 归并排序 (递归实现)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    *</div><div class="line">    * <span class="doctag">@param</span> 排序数组</div><div class="line">    * <span class="doctag">@param</span> 数组开头下标</div><div class="line">    * <span class="doctag">@param</span> 数组长度</div><div class="line">    * <span class="doctag">@return</span></div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> h) &#123;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (l == h) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a[l]&#125;;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">int</span> middle = l+(h-l)/<span class="number">2</span>;</div><div class="line">       <span class="keyword">int</span>[] leftArray = mergeSort(a, l, middle);</div><div class="line">       <span class="keyword">int</span>[] rightArray = mergeSort(a, middle+<span class="number">1</span>, h);</div><div class="line">       <span class="comment">//新有序数组</span></div><div class="line">       <span class="keyword">int</span>[] newNum = <span class="keyword">new</span> <span class="keyword">int</span>[leftArray.length + rightArray.length];</div><div class="line"></div><div class="line">       <span class="keyword">int</span> leftIndex=<span class="number">0</span>,rightIndex=<span class="number">0</span>,newIndex=<span class="number">0</span>;</div><div class="line"></div><div class="line">       <span class="keyword">while</span> (leftIndex &lt; leftArray.length &amp;&amp; rightIndex &lt; rightArray.length) &#123;</div><div class="line">           newNum[newIndex++]= leftArray[leftIndex]&lt;rightArray[rightIndex]?leftArray[leftIndex++]:rightArray[rightIndex++];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">while</span> (leftIndex &lt; leftArray.length) &#123;</div><div class="line">           newNum[newIndex++] = leftArray[leftIndex++];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">while</span> (rightIndex &lt; rightArray.length) &#123;</div><div class="line">           newNum[newIndex++] = rightArray[rightIndex++];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> newNum;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="QUI-快速排序-递归实现"><a href="#QUI-快速排序-递归实现" class="headerlink" title="QUI - 快速排序 (递归实现)"></a>QUI - 快速排序 (递归实现)</h3><h3 id="R-Q-随机快速排序-递归实现"><a href="#R-Q-随机快速排序-递归实现" class="headerlink" title="R-Q - 随机快速排序 (递归实现)"></a>R-Q - 随机快速排序 (递归实现)</h3><h2 id="不基于比较的排序算法"><a href="#不基于比较的排序算法" class="headerlink" title="不基于比较的排序算法:"></a>不基于比较的排序算法:</h2><h3 id="COU-计数排序"><a href="#COU-计数排序" class="headerlink" title="COU - 计数排序"></a>COU - 计数排序</h3><h3 id="RAD-基数排序"><a href="#RAD-基数排序" class="headerlink" title="RAD - 基数排序"></a>RAD - 基数排序</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;h2 id=&quot;基于比较的排序算法&quot;&gt;&lt;a href=&quot;#基于比较的排序算法&quot; class=&quot;headerlink&quot; title=&quot;基于比较的排序
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/mac%20%E6%8C%89%E9%94%AE%E7%AC%A6%E5%8F%B7/"/>
    <id>http://code.idea4j.com/2020/09/11/mac 按键符号/</id>
    <published>2020-09-11T05:53:44.767Z</published>
    <updated>2020-09-11T05:53:44.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac按键符号"><a href="#mac按键符号" class="headerlink" title="mac按键符号"></a>mac按键符号</h1><p>符号    说明<br>⌘    Command<br>⇧    Shift<br>⌥    Option<br>⌃    Control<br>↩︎    Return/Enter<br>⌫    Delete<br>⌦    向前删除键（Fn+Delete）<br>↑    上箭头<br>↓    下箭头<br>→    右箭头<br>←    左箭头<br>⇞    Page Up（Fn+↑）<br>⇟    Page Down（Fn+↓）<br>Home    Fn + ←<br>End    Fn + →<br>⇥    右制表符（Tab键）<br>⇤    左制表符（Shift+Tab）<br>⎋    Escape (Esc)</p>
<h2 id="mac输入特殊符号的方法"><a href="#mac输入特殊符号的方法" class="headerlink" title="mac输入特殊符号的方法"></a>mac输入特殊符号的方法</h2><p>⚠️ ⌘+⌃+space 可以直接调出输入表情和特殊符号的选框, 开始显示的是emoji表情, 一直往下面拉滑或者点右上角的图标就是各种特殊符号咯.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mac按键符号&quot;&gt;&lt;a href=&quot;#mac按键符号&quot; class=&quot;headerlink&quot; title=&quot;mac按键符号&quot;&gt;&lt;/a&gt;mac按键符号&lt;/h1&gt;&lt;p&gt;符号    说明&lt;br&gt;⌘    Command&lt;br&gt;⇧    Shift&lt;br&gt;⌥    Opt
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/java%E6%B3%9B%E5%9E%8B/"/>
    <id>http://code.idea4j.com/2020/09/11/java泛型/</id>
    <published>2020-09-11T05:53:44.766Z</published>
    <updated>2020-09-11T05:53:44.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a>java泛型</h1><p>Java从1.5之后支持泛型，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p>
<p>1.类型安全。泛型的主要目标是提高Java程序的类型安全。通过知道使用放心定义的变量的类型限制，并且可以在一个高得多的成熟度上验证类型。假设如果没有反省，这些假设就只存在于程序员的头脑中消除强制。一类型安全范畴的主要目标是提高Java程序的类型安全通过知道使用放心定义的变量的类型限制，并且可以在一个高得多的成熟度上验证类型。假设如果没有反省，这些假设就只存在于程序员的头脑中。</p>
<p>2.消除强制类型转换翻新的一个附带的好处，是消除源代码中，许多强制类型转换，这使得代码更加可读，并且减少了出错的机会，</p>
<p>3000赞的性能收益饭行为较大的优化带来了可能在梵行的初始视线中，编译器将强制类型。消除强制类型转换翻新的一个附带的好处，是消除源代码中，许多强制类型转换，这使得代码更加可读，并且减少了出错的机会，3000赞的性能收益饭行为较大的优化带来了可能在梵行的初始视线中，编译器将强制类型。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java泛型&quot;&gt;&lt;a href=&quot;#java泛型&quot; class=&quot;headerlink&quot; title=&quot;java泛型&quot;&gt;&lt;/a&gt;java泛型&lt;/h1&gt;&lt;p&gt;Java从1.5之后支持泛型，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://code.idea4j.com/2020/09/11/java性能优化/</id>
    <published>2020-09-11T05:53:44.765Z</published>
    <updated>2020-09-11T05:53:44.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java性能优化"><a href="#java性能优化" class="headerlink" title="java性能优化"></a>java性能优化</h3><p>项目的并发量级是多少？</p>
<p>有没有性能问题诊断和优化的生产经验</p>
<p>说说你过往项目的真实调优过程，常用指标有哪些？</p>
<p>jvm参数设置大小的依据是什么？</p>
<p>解决过索引失效问题吗？</p>
<p>基于并发量要求你会从哪些维度考虑</p>
<p>网络宽带，QPS，TPS，连接数，数据量级</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java性能优化&quot;&gt;&lt;a href=&quot;#java性能优化&quot; class=&quot;headerlink&quot; title=&quot;java性能优化&quot;&gt;&lt;/a&gt;java性能优化&lt;/h3&gt;&lt;p&gt;项目的并发量级是多少？&lt;/p&gt;
&lt;p&gt;有没有性能问题诊断和优化的生产经验&lt;/p&gt;
&lt;p&gt;说说
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/dubbo%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://code.idea4j.com/2020/09/11/dubbo的原理/</id>
    <published>2020-09-11T05:53:44.763Z</published>
    <updated>2020-09-11T05:53:44.763Z</updated>
    
    <content type="html"><![CDATA[<p>dubbo的原理</p>
<p>scp r cm pets</p>
<p>框架设计</p>
<p>启动解析</p>
<p>服务暴露</p>
<p>服务引用</p>
<p>服务调用</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dubbo的原理&lt;/p&gt;
&lt;p&gt;scp r cm pets&lt;/p&gt;
&lt;p&gt;框架设计&lt;/p&gt;
&lt;p&gt;启动解析&lt;/p&gt;
&lt;p&gt;服务暴露&lt;/p&gt;
&lt;p&gt;服务引用&lt;/p&gt;
&lt;p&gt;服务调用&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/Zuul%E4%B8%8EGateWay%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>http://code.idea4j.com/2020/09/11/Zuul与GateWay有什么区别/</id>
    <published>2020-09-11T05:53:44.762Z</published>
    <updated>2020-09-11T05:53:44.762Z</updated>
    
    <content type="html"><![CDATA[<p>网关</p>
<p>作用：可以实现</p>
<h3 id="Zuul与GateWay有什么区别"><a href="#Zuul与GateWay有什么区别" class="headerlink" title="Zuul与GateWay有什么区别"></a>Zuul与GateWay有什么区别</h3><p>Zuul网关属于Nettfix公司开源框架，需要第一代微服务网关</p>
<p>GateWay属于SpringCloud自己研发的网关框架，属于第二代网关</p>
<p>相比来说GateWay比Zuul网关性能好</p>
<p>Zuul网关底层基于Servlet实现的，阻塞式api，不支持长连接</p>
<p>SpringCloudGateWay基于Spring5构建，能够实现响应式非阻塞式api，支持长连接，更好的支持Spring系列产品，依赖Springboot-webflux。</p>
<h3 id="网关与Nginx的区别"><a href="#网关与Nginx的区别" class="headerlink" title="网关与Nginx的区别"></a>网关与Nginx的区别</h3><p>相同点：都可以实现api拦截，负载均衡，反向代理，请求过滤等</p>
<p>不同点：Nginx采用c语言</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网关&lt;/p&gt;
&lt;p&gt;作用：可以实现&lt;/p&gt;
&lt;h3 id=&quot;Zuul与GateWay有什么区别&quot;&gt;&lt;a href=&quot;#Zuul与GateWay有什么区别&quot; class=&quot;headerlink&quot; title=&quot;Zuul与GateWay有什么区别&quot;&gt;&lt;/a&gt;Zuul与GateW
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://code.idea4j.com/2020/09/11/Spring%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://code.idea4j.com/2020/09/11/Spring事务隔离级别/</id>
    <published>2020-09-11T05:53:44.761Z</published>
    <updated>2020-09-11T05:53:44.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring事务隔离级别"><a href="#Spring事务隔离级别" class="headerlink" title="Spring事务隔离级别"></a>Spring事务隔离级别</h2><p>一、Propagation （事务的传播属性）</p>
<p>Propagation ：　　key属性确定代理应该给哪个方法增加事务行为。这样的属性最重要的部份是传播行为。有以下选项可供使用：PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。<br>PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。<br>PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。<br>PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<p>1： PROPAGATION_REQUIRED<br>加入当前正要执行的事务不在另外一个事务里，那么就起一个新的事务<br>比如说，ServiceB.methodB的事务级别定义为PROPAGATION_REQUIRED, 那么由于执行ServiceA.methodA的时候，<br>ServiceA.methodA已经起了事务，这时调用ServiceB.methodB，ServiceB.methodB看到自己已经运行在ServiceA.methodA<br>的事务内部，就不再起新的事务。而假如ServiceA.methodA运行的时候发现自己没有在事务中，他就会为自己分配一个事务。<br>这样，在ServiceA.methodA或者在ServiceB.methodB内的任何地方出现异常，事务都会被回滚。即使ServiceB.methodB的事务已经被<br>提交，但是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚</p>
<p>2： PROPAGATION_SUPPORTS<br>如果当前在事务中，即以事务的形式运行，如果当前不再一个事务中，那么就以非事务的形式运行</p>
<p>3： PROPAGATION_MANDATORY<br>必须在一个事务中运行。也就是说，他只能被一个父事务调用。否则，他就要抛出异常</p>
<p>4： PROPAGATION_REQUIRES_NEW<br>这个就比较绕口了。 比如我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW，<br>那么当执行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起，ServiceB.methodB会起一个新的事务，等待ServiceB.methodB的事务完成以后，<br>他才继续执行。他与PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在<br>两个不同的事务。如果ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚，ServiceB.methodB是不会回滚的。如果ServiceB.methodB失败回滚，<br>如果他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。</p>
<p>5： PROPAGATION_NOT_SUPPORTED<br>当前不支持事务。比如ServiceA.methodA的事务级别是PROPAGATION_REQUIRED ，而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，<br>那么当执行到ServiceB.methodB时，ServiceA.methodA的事务挂起，而他以非事务的状态运行完，再继续ServiceA.methodA的事务。</p>
<p>6： PROPAGATION_NEVER<br>不能在事务中运行。假设ServiceA.methodA的事务级别是PROPAGATION_REQUIRED， 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，<br>那么ServiceB.methodB就要抛出异常了。</p>
<p>7： PROPAGATION_NESTED<br>理解Nested的关键是savepoint。他与PROPAGATION_REQUIRES_NEW的区别是，PROPAGATION_REQUIRES_NEW另起一个事务，将会与他的父事务相互独立，<br>而Nested的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。<br>而Nested事务的好处是他有一个savepoint。</p>
<hr>
<p>ServiceA {</p>
<p>/<em>*<br>\</em> 事务属性配置为 PROPAGATION_REQUIRED<br>*/<br>void methodA() {<br>try {<br>//savepoint<br>ServiceB.methodB(); //PROPAGATION_NESTED 级别<br>} catch (SomeException) {<br>// 执行其他业务, 如 ServiceC.methodC();<br>}<br>}</p>
<p>}</p>
<hr>
<p>也就是说ServiceB.methodB失败回滚，那么ServiceA.methodA也会回滚到savepoint点上，ServiceA.methodA可以选择另外一个分支，比如<br>ServiceC.methodC，继续执行，来尝试完成自己的事务。<br>但是这个事务并没有在EJB标准中定义。</p>
<p>Spring事务的隔离级别<br> \1. ISOLATION_DEFAULT： 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.<br>   另外四个与JDBC的隔离级别相对应<br> \2. ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。<br>   这种隔离级别会产生脏读，不可重复读和幻像读。<br> \3. ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据<br> \4. ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。<br>   它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。<br> \5. ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。<br>   除了防止脏读，不可重复读外，还避免了幻像读。</p>
<p>什么是脏数据，脏读，不可重复读，幻觉读？<br> 脏读: 指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，<br>   另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一<br>   个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p>
<p> 不可重复读: 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。<br>       那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据<br>       可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p>
<p> 幻觉读: 指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及<br>     到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，<br>     以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring事务隔离级别&quot;&gt;&lt;a href=&quot;#Spring事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;Spring事务隔离级别&quot;&gt;&lt;/a&gt;Spring事务隔离级别&lt;/h2&gt;&lt;p&gt;一、Propagation （事务的传播属性）&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
</feed>
